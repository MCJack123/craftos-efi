const char * bios_str = "local nativegetfenv = getfenv\n"
"if _VERSION == \"Lua 5.1\" then\n"
"    -- If we're on Lua 5.1, install parts of the Lua 5.2/5.3 API so that programs can be written against it\n"
"    local nativeload = load\n"
"    local nativeloadstring = loadstring\n"
"    local nativesetfenv = setfenv\n"
"    _G.xpcall = function( _fn, _fnErrorHandler )\n"
"    local typeT = type( _fn )\n"
"    assert( typeT == \"function\", \"bad argument #1 to xpcall (function expected, got \"..typeT..\")\" )\n"
"    local co = coroutine.create( _fn )\n"
"    local tResults = { coroutine.resume( co ) }\n"
"    while coroutine.status( co ) ~= \"dead\" do\n"
"        tResults = { coroutine.resume( co, coroutine.yield() ) }\n"
"    end\n"
"    if tResults[1] == true then\n"
"        return true, unpack( tResults, 2 )\n"
"    else\n"
"        return false, _fnErrorHandler( tResults[2] )\n"
"    end\n"
"end\n"
"\n"
"    _G.pcall = function( _fn, ... )\n"
"    local typeT = type( _fn )\n"
"    assert( typeT == \"function\", \"bad argument #1 to pcall (function expected, got \"..typeT..\")\" )\n"
"    local tArgs = { ... }\n"
"    return xpcall(\n"
"        function()\n"
"            return _fn( unpack( tArgs ) )\n"
"        end,\n"
"        function( _error )\n"
"            return _error\n"
"        end\n"
"    )\n"
"end\n"
"    function load( x, name, mode, env )\n"
"        if type( x ) ~= \"string\" and type( x ) ~= \"function\" then\n"
"            error( \"bad argument #1 (expected string or function, got \" .. type( x ) .. \")\", 2 ) \n"
"        end\n"
"        if name ~= nil and type( name ) ~= \"string\" then\n"
"            error( \"bad argument #2 (expected string, got \" .. type( name ) .. \")\", 2 ) \n"
"        end\n"
"        if mode ~= nil and type( mode ) ~= \"string\" then\n"
"            error( \"bad argument #3 (expected string, got \" .. type( mode ) .. \")\", 2 ) \n"
"        end\n"
"        if env ~= nil and type( env) ~= \"table\" then\n"
"            error( \"bad argument #4 (expected table, got \" .. type( env ) .. \")\", 2 ) \n"
"        end\n"
"        if mode ~= nil and mode ~= \"t\" then\n"
"            error( \"Binary chunk loading prohibited\", 2 )\n"
"        end\n"
"        local ok, p1, p2 = pcall( function()        \n"
"            if type(x) == \"string\" then\n"
"                local result, err = nativeloadstring( x, name )\n"
"                if result then\n"
"                    if env then\n"
"                        env._ENV = env\n"
"                        nativesetfenv( result, env )\n"
"                    end\n"
"                    return result\n"
"                else\n"
"                    return nil, err\n"
"                end\n"
"            else\n"
"                local result, err = nativeload( x, name )\n"
"                if result then\n"
"                    if env then\n"
"                        env._ENV = env\n"
"                        nativesetfenv( result, env )\n"
"                    end\n"
"                    return result\n"
"                else\n"
"                    return nil, err\n"
"                end\n"
"            end\n"
"        end )\n"
"        if ok then\n"
"            return p1, p2\n"
"        else\n"
"            error( p1, 2 )\n"
"        end        \n"
"    end\n"
"    table.unpack = unpack\n"
"    table.pack = function( ... ) return { n = select( \"#\", ... ), ... } end\n"
"\n"
"    -- Install the bit32 api\n"
"    local nativebit = bit\n"
"    bit32 = {}\n"
"    bit32.arshift = nativebit.brshift\n"
"    bit32.band = nativebit.band\n"
"    bit32.bnot = nativebit.bnot\n"
"    bit32.bor = nativebit.bor\n"
"    bit32.btest = function( a, b ) return nativebit.band(a,b) ~= 0 end\n"
"    bit32.bxor = nativebit.bxor\n"
"    bit32.lshift = nativebit.blshift\n"
"    bit32.rshift = nativebit.blogic_rshift\n"
"\n"
"    if _CC_DISABLE_LUA51_FEATURES then\n"
"        -- Remove the Lua 5.1 features that will be removed when we update to Lua 5.2, for compatibility testing.\n"
"        -- See \"disable_lua51_functions\" in ComputerCraft.cfg\n"
"        setfenv = nil\n"
"        getfenv = nil\n"
"        loadstring = nil\n"
"        unpack = nil\n"
"        math.log10 = nil\n"
"        table.maxn = nil\n"
"        bit = nil\n"
"    end\n"
"end\n"
"\n"
"if _VERSION == \"Lua 5.3\" then\n"
"    -- If we're on Lua 5.3, install the bit32 api from Lua 5.2\n"
"    -- (Loaded from a string so this file will still parse on <5.3 lua)\n"
"    load( [[\n"
"        bit32 = {}\n"
"\n"
"        function bit32.arshift( n, bits )\n"
"            if type(n) ~= \"number\" or type(bits) ~= \"number\" then\n"
"                error( \"Expected number, number\", 2 )\n"
"            end\n"
"            return n >> bits\n"
"        end\n"
"\n"
"        function bit32.band( m, n )\n"
"            if type(m) ~= \"number\" or type(n) ~= \"number\" then\n"
"                error( \"Expected number, number\", 2 )\n"
"            end\n"
"            return m & n\n"
"        end\n"
"\n"
"        function bit32.bnot( n )\n"
"            if type(n) ~= \"number\" then\n"
"                error( \"Expected number\", 2 )\n"
"            end\n"
"            return ~n\n"
"        end\n"
"\n"
"        function bit32.bor( m, n )\n"
"            if type(m) ~= \"number\" or type(n) ~= \"number\" then\n"
"                error( \"Expected number, number\", 2 )\n"
"            end\n"
"            return m | n\n"
"        end\n"
"\n"
"        function bit32.btest( m, n )\n"
"            if type(m) ~= \"number\" or type(n) ~= \"number\" then\n"
"                error( \"Expected number, number\", 2 )\n"
"            end\n"
"            return (m & n) ~= 0\n"
"        end\n"
"\n"
"        function bit32.bxor( m, n )\n"
"            if type(m) ~= \"number\" or type(n) ~= \"number\" then\n"
"                error( \"Expected number, number\", 2 )\n"
"            end\n"
"            return m ~ n\n"
"        end\n"
"\n"
"        function bit32.lshift( n, bits )\n"
"            if type(n) ~= \"number\" or type(bits) ~= \"number\" then\n"
"                error( \"Expected number, number\", 2 )\n"
"            end\n"
"            return n << bits\n"
"        end\n"
"\n"
"        function bit32.rshift( n, bits )\n"
"            if type(n) ~= \"number\" or type(bits) ~= \"number\" then\n"
"                error( \"Expected number, number\", 2 )\n"
"            end\n"
"            return n >> bits\n"
"        end\n"
"    ]] )()\n"
"end\n"
"\n"
"if string.find( _HOST, \"ComputerCraft\" ) == 1 then\n"
"    -- Prevent access to metatables or environments of strings, as these are global between all computers\n"
"    local nativegetmetatable = getmetatable\n"
"    local nativeerror = error\n"
"    local nativetype = type\n"
"    local string_metatable = nativegetmetatable(\"\")\n"
"    function getmetatable( t )\n"
"        local mt = nativegetmetatable( t )\n"
"        if mt == string_metatable then\n"
"            nativeerror( \"Attempt to access string metatable\", 2 )\n"
"        else\n"
"            return mt\n"
"        end\n"
"    end\n"
"    if _VERSION == \"Lua 5.1\" and not _CC_DISABLE_LUA51_FEATURES then\n"
"        local string_env = nativegetfenv((\"\").gsub)\n"
"        function getfenv( env )\n"
"            if env == nil then\n"
"                env = 2\n"
"            elseif nativetype( env ) == \"number\" and env > 0 then\n"
"                env = env + 1\n"
"            end\n"
"            local fenv = nativegetfenv(env)\n"
"            if fenv == string_env then\n"
"                --nativeerror( \"Attempt to access string metatable\", 2 )\n"
"                return nativegetfenv( 0 )\n"
"            else\n"
"                return fenv\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- Install lua parts of the os api\n"
"function os.version()\n"
"    return \"CraftOS 1.8\"\n"
"end\n"
"\n"
"function os.pullEventRaw( sFilter )\n"
"    return coroutine.yield( sFilter )\n"
"end\n"
"\n"
"function os.pullEvent( sFilter )\n"
"    local eventData = table.pack( os.pullEventRaw( sFilter ) )\n"
"    if eventData[1] == \"terminate\" then\n"
"        error( \"Terminated\", 0 )\n"
"    end\n"
"    return table.unpack( eventData, 1, eventData.n )\n"
"end\n"
"\n"
"-- Install globals\n"
"function sleep( nTime )\n"
"    if nTime ~= nil and type( nTime ) ~= \"number\" then\n"
"        error( \"bad argument #1 (expected number, got \" .. type( nTime ) .. \")\", 2 ) \n"
"    end\n"
"    local timer = os.startTimer( nTime or 0 )\n"
"    repeat\n"
"        local sEvent, param = os.pullEvent( \"timer\" )\n"
"    until param == timer\n"
"end\n"
"\n"
"function write( sText )\n"
"    if type( sText ) ~= \"string\" and type( sText ) ~= \"number\" then\n"
"        error( \"bad argument #1 (expected string or number, got \" .. type( sText ) .. \")\", 2 ) \n"
"    end\n"
"\n"
"    local w,h = term.getSize()        \n"
"    local x,y = term.getCursorPos()\n"
"    \n"
"    local nLinesPrinted = 0\n"
"    local function newLine()\n"
"        if y + 1 <= h then\n"
"            term.setCursorPos(1, y + 1)\n"
"        else\n"
"            term.setCursorPos(1, h)\n"
"            term.scroll(1)\n"
"        end\n"
"        x, y = term.getCursorPos()\n"
"        nLinesPrinted = nLinesPrinted + 1\n"
"    end\n"
"    \n"
"    -- Print the line with proper word wrapping\n"
"    while string.len(sText) > 0 do\n"
"        local whitespace = string.match( sText, \"^[ \\t]+\" )\n"
"        if whitespace then\n"
"            -- Print whitespace\n"
"            term.write( whitespace )\n"
"            x,y = term.getCursorPos()\n"
"            sText = string.sub( sText, string.len(whitespace) + 1 )\n"
"        end\n"
"        \n"
"        local newline = string.match( sText, \"^\\n\" )\n"
"        if newline then\n"
"            -- Print newlines\n"
"            newLine()\n"
"            sText = string.sub( sText, 2 )\n"
"        end\n"
"        \n"
"        local text = string.match( sText, \"^[^ \\t\\n]+\" )\n"
"        if text then\n"
"            sText = string.sub( sText, string.len(text) + 1 )\n"
"            if string.len(text) > w then\n"
"                -- Print a multiline word                \n"
"                while string.len( text ) > 0 do\n"
"                    if x > w then\n"
"                        newLine()\n"
"                    end\n"
"                    term.write( text )\n"
"                    text = string.sub( text, (w-x) + 2 )\n"
"                    x,y = term.getCursorPos()\n"
"                end\n"
"            else\n"
"                -- Print a word normally\n"
"                if x + string.len(text) - 1 > w then\n"
"                    newLine()\n"
"                end\n"
"                term.write( text )\n"
"                x,y = term.getCursorPos()\n"
"            end\n"
"        end\n"
"    end\n"
"    \n"
"    return nLinesPrinted\n"
"end\n"
"\n"
"function print( ... )\n"
"    local nLinesPrinted = 0\n"
"    local nLimit = select(\"#\", ... )\n"
"    for n = 1, nLimit do\n"
"        local s = tostring( select( n, ... ) )\n"
"        if n < nLimit then\n"
"            s = s .. \"\\t\"\n"
"        end\n"
"        nLinesPrinted = nLinesPrinted + write( s )\n"
"    end\n"
"    nLinesPrinted = nLinesPrinted + write( \"\\n\" )\n"
"    return nLinesPrinted\n"
"end\n"
"\n"
"function printError( ... )\n"
"    local oldColour\n"
"    if term.isColour() then\n"
"        oldColour = term.getTextColour()\n"
"        term.setTextColour( 16384 )\n"
"    end\n"
"    print( ... )\n"
"    if term.isColour() then\n"
"        term.setTextColour( oldColour )\n"
"    end\n"
"end\n"
"\n"
"function read( _sReplaceChar, _tHistory, _fnComplete, _sDefault )\n"
"    if _sReplaceChar ~= nil and type( _sReplaceChar ) ~= \"string\" then\n"
"        error( \"bad argument #1 (expected string, got \" .. type( _sReplaceChar ) .. \")\", 2 ) \n"
"    end\n"
"    if _tHistory ~= nil and type( _tHistory ) ~= \"table\" then\n"
"        error( \"bad argument #2 (expected table, got \" .. type( _tHistory ) .. \")\", 2 ) \n"
"    end\n"
"    if _fnComplete ~= nil and type( _fnComplete ) ~= \"function\" then\n"
"        error( \"bad argument #3 (expected function, got \" .. type( _fnComplete ) .. \")\", 2 ) \n"
"    end\n"
"    if _sDefault ~= nil and type( _sDefault ) ~= \"string\" then\n"
"        error( \"bad argument #4 (expected string, got \" .. type( _sDefault ) .. \")\", 2 ) \n"
"    end\n"
"    term.setCursorBlink( true )\n"
"\n"
"    local sLine\n"
"    if type( _sDefault ) == \"string\" then\n"
"        sLine = _sDefault\n"
"    else\n"
"        sLine = \"\"\n"
"    end\n"
"    local nHistoryPos\n"
"    local nPos = #sLine\n"
"    if _sReplaceChar then\n"
"        _sReplaceChar = string.sub( _sReplaceChar, 1, 1 )\n"
"    end\n"
"\n"
"    local tCompletions\n"
"    local nCompletion\n"
"    local function recomplete()\n"
"        if _fnComplete and nPos == string.len(sLine) then\n"
"            tCompletions = _fnComplete( sLine )\n"
"            if tCompletions and #tCompletions > 0 then\n"
"                nCompletion = 1\n"
"            else\n"
"                nCompletion = nil\n"
"            end\n"
"        else\n"
"            tCompletions = nil\n"
"            nCompletion = nil\n"
"        end\n"
"    end\n"
"\n"
"    local function uncomplete()\n"
"        tCompletions = nil\n"
"        nCompletion = nil\n"
"    end\n"
"\n"
"    local w = term.getSize()\n"
"    local sx = term.getCursorPos()\n"
"\n"
"    local function redraw( _bClear )\n"
"        local nScroll = 0\n"
"        if sx + nPos >= w then\n"
"            nScroll = (sx + nPos) - w\n"
"        end\n"
"\n"
"        local cx,cy = term.getCursorPos()\n"
"        term.setCursorPos( sx, cy )\n"
"        local sReplace = (_bClear and \" \") or _sReplaceChar\n"
"        if sReplace then\n"
"            term.write( string.rep( sReplace, math.max( string.len(sLine) - nScroll, 0 ) ) )\n"
"        else\n"
"            term.write( string.sub( sLine, nScroll + 1 ) )\n"
"        end\n"
"\n"
"        if nCompletion then\n"
"            local sCompletion = tCompletions[ nCompletion ]\n"
"            local oldText, oldBg\n"
"            if not _bClear then\n"
"                oldText = term.getTextColor()\n"
"                oldBg = term.getBackgroundColor()\n"
"                term.setTextColor( colors.white )\n"
"                term.setBackgroundColor( colors.gray )\n"
"            end\n"
"            if sReplace then\n"
"                term.write( string.rep( sReplace, string.len( sCompletion ) ) )\n"
"            else\n"
"                term.write( sCompletion )\n"
"            end\n"
"            if not _bClear then\n"
"                term.setTextColor( oldText )\n"
"                term.setBackgroundColor( oldBg )\n"
"            end\n"
"        end\n"
"\n"
"        term.setCursorPos( sx + nPos - nScroll, cy )\n"
"    end\n"
"    \n"
"    local function clear()\n"
"        redraw( true )\n"
"    end\n"
"\n"
"    recomplete()\n"
"    redraw()\n"
"\n"
"    local function acceptCompletion()\n"
"        if nCompletion then\n"
"            -- Clear\n"
"            clear()\n"
"\n"
"            -- Find the common prefix of all the other suggestions which start with the same letter as the current one\n"
"            local sCompletion = tCompletions[ nCompletion ]\n"
"            sLine = sLine .. sCompletion\n"
"            nPos = string.len( sLine )\n"
"\n"
"            -- Redraw\n"
"            recomplete()\n"
"            redraw()\n"
"        end\n"
"    end\n"
"    while true do\n"
"        local sEvent, param = os.pullEvent()\n"
"        if sEvent == \"char\" then\n"
"            -- Typed key\n"
"            clear()\n"
"            sLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )\n"
"            nPos = nPos + 1\n"
"            recomplete()\n"
"            redraw()\n"
"\n"
"        elseif sEvent == \"paste\" then\n"
"            -- Pasted text\n"
"            clear()\n"
"            sLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )\n"
"            nPos = nPos + string.len( param )\n"
"            recomplete()\n"
"            redraw()\n"
"\n"
"        elseif sEvent == \"key\" then\n"
"            if param == keys.enter then\n"
"                -- Enter\n"
"                if nCompletion then\n"
"                    clear()\n"
"                    uncomplete()\n"
"                    redraw()\n"
"                end\n"
"                break\n"
"                \n"
"            elseif param == keys.left then\n"
"                -- Left\n"
"                if nPos > 0 then\n"
"                    clear()\n"
"                    nPos = nPos - 1\n"
"                    recomplete()\n"
"                    redraw()\n"
"                end\n"
"                \n"
"            elseif param == keys.right then\n"
"                -- Right                \n"
"                if nPos < string.len(sLine) then\n"
"                    -- Move right\n"
"                    clear()\n"
"                    nPos = nPos + 1\n"
"                    recomplete()\n"
"                    redraw()\n"
"                else\n"
"                    -- Accept autocomplete\n"
"                    acceptCompletion()\n"
"                end\n"
"\n"
"            elseif param == keys.up or param == keys.down then\n"
"                -- Up or down\n"
"                if nCompletion then\n"
"                    -- Cycle completions\n"
"                    clear()\n"
"                    if param == keys.up then\n"
"                        nCompletion = nCompletion - 1\n"
"                        if nCompletion < 1 then\n"
"                            nCompletion = #tCompletions\n"
"                        end\n"
"                    elseif param == keys.down then\n"
"                        nCompletion = nCompletion + 1\n"
"                        if nCompletion > #tCompletions then\n"
"                            nCompletion = 1\n"
"                        end\n"
"                    end\n"
"                    redraw()\n"
"\n"
"                elseif _tHistory then\n"
"                    -- Cycle history\n"
"                    clear()\n"
"                    if param == keys.up then\n"
"                        -- Up\n"
"                        if nHistoryPos == nil then\n"
"                            if #_tHistory > 0 then\n"
"                                nHistoryPos = #_tHistory\n"
"                            end\n"
"                        elseif nHistoryPos > 1 then\n"
"                            nHistoryPos = nHistoryPos - 1\n"
"                        end\n"
"                    else\n"
"                        -- Down\n"
"                        if nHistoryPos == #_tHistory then\n"
"                            nHistoryPos = nil\n"
"                        elseif nHistoryPos ~= nil then\n"
"                            nHistoryPos = nHistoryPos + 1\n"
"                        end                        \n"
"                    end\n"
"                    if nHistoryPos then\n"
"                        sLine = _tHistory[nHistoryPos]\n"
"                        nPos = string.len( sLine ) \n"
"                    else\n"
"                        sLine = \"\"\n"
"                        nPos = 0\n"
"                    end\n"
"                    uncomplete()\n"
"                    redraw()\n"
"\n"
"                end\n"
"\n"
"            elseif param == keys.backspace then\n"
"                -- Backspace\n"
"                if nPos > 0 then\n"
"                    clear()\n"
"                    sLine = string.sub( sLine, 1, nPos - 1 ) .. string.sub( sLine, nPos + 1 )\n"
"                    nPos = nPos - 1\n"
"                    recomplete()\n"
"                    redraw()\n"
"                end\n"
"\n"
"            elseif param == keys.home then\n"
"                -- Home\n"
"                if nPos > 0 then\n"
"                    clear()\n"
"                    nPos = 0\n"
"                    recomplete()\n"
"                    redraw()\n"
"                end\n"
"\n"
"            elseif param == keys.delete then\n"
"                -- Delete\n"
"                if nPos < string.len(sLine) then\n"
"                    clear()\n"
"                    sLine = string.sub( sLine, 1, nPos ) .. string.sub( sLine, nPos + 2 )                \n"
"                    recomplete()\n"
"                    redraw()\n"
"                end\n"
"\n"
"            elseif param == keys[\"end\"] then\n"
"                -- End\n"
"                if nPos < string.len(sLine ) then\n"
"                    clear()\n"
"                    nPos = string.len(sLine)\n"
"                    recomplete()\n"
"                    redraw()\n"
"                end\n"
"\n"
"            elseif param == keys.tab then\n"
"                -- Tab (accept autocomplete)\n"
"                acceptCompletion()\n"
"\n"
"            end\n"
"\n"
"        elseif sEvent == \"term_resize\" then\n"
"            -- Terminal resized\n"
"            w = term.getSize()\n"
"            redraw()\n"
"\n"
"        end\n"
"    end\n"
"\n"
"    local cx, cy = term.getCursorPos()\n"
"    term.setCursorBlink( false )\n"
"    term.setCursorPos( w + 1, cy )\n"
"    print()\n"
"    \n"
"    return sLine\n"
"end\n"
"\n"
"loadfile = function( _sFile, _tEnv )\n"
"    if type( _sFile ) ~= \"string\" then\n"
"        error( \"bad argument #1 (expected string, got \" .. type( _sFile ) .. \")\", 2 ) \n"
"    end\n"
"    if _tEnv ~= nil and type( _tEnv ) ~= \"table\" then\n"
"        error( \"bad argument #2 (expected table, got \" .. type( _tEnv ) .. \")\", 2 ) \n"
"    end\n"
"    local file = fs.open( _sFile, \"r\" )\n"
"    if file then\n"
"        local func, err = load( file.readAll(), fs.getName( _sFile ), \"t\", _tEnv )\n"
"        file.close()\n"
"        return func, err\n"
"    end\n"
"    return nil, \"File not found\"\n"
"end\n"
"\n"
"dofile = function( _sFile )\n"
"    if type( _sFile ) ~= \"string\" then\n"
"        error( \"bad argument #1 (expected string, got \" .. type( _sFile ) .. \")\", 2 ) \n"
"    end\n"
"    local fnFile, e = loadfile( _sFile, _G )\n"
"    if fnFile then\n"
"        return fnFile()\n"
"    else\n"
"        error( e, 2 )\n"
"    end\n"
"end\n"
"\n"
"-- Install the rest of the OS api\n"
"function os.run( _tEnv, _sPath, ... )\n"
"    if type( _tEnv ) ~= \"table\" then\n"
"        error( \"bad argument #1 (expected table, got \" .. type( _tEnv ) .. \")\", 2 ) \n"
"    end\n"
"    if type( _sPath ) ~= \"string\" then\n"
"        error( \"bad argument #2 (expected string, got \" .. type( _sPath ) .. \")\", 2 ) \n"
"    end\n"
"    local tArgs = table.pack( ... )\n"
"    local tEnv = _tEnv\n"
"    setmetatable( tEnv, { __index = _G } )\n"
"    local fnFile, err = loadfile( _sPath, tEnv )\n"
"    if fnFile then\n"
"        local ok, err = pcall( function()\n"
"            fnFile( table.unpack( tArgs, 1, tArgs.n ) )\n"
"        end )\n"
"        if not ok then\n"
"            if err and err ~= \"\" then\n"
"                printError( err )\n"
"            end\n"
"            return false\n"
"        end\n"
"        return true\n"
"    end\n"
"    if err and err ~= \"\" then\n"
"        printError( err )\n"
"    end\n"
"    return false\n"
"end\n"
"\n"
"local tAPIsLoading = {}\n"
"function os.loadAPI( _sPath )\n"
"    if type( _sPath ) ~= \"string\" then\n"
"        error( \"bad argument #1 (expected string, got \" .. type( _sPath ) .. \")\", 2 ) \n"
"    end\n"
"    local sName = fs.getName( _sPath )\n"
"    if sName:sub(-4) == \".lua\" then\n"
"        sName = sName:sub(1,-5)\n"
"    end\n"
"    if tAPIsLoading[sName] == true then\n"
"        printError( \"API \"..sName..\" is already being loaded\" )\n"
"        return false\n"
"    end\n"
"    tAPIsLoading[sName] = true\n"
"\n"
"    local tEnv = {}\n"
"    setmetatable( tEnv, { __index = _G } )\n"
"    local fnAPI, err = loadfile( _sPath, tEnv )\n"
"    if fnAPI then\n"
"        local ok, err = pcall( fnAPI )\n"
"        if not ok then\n"
"            printError( err )\n"
"            tAPIsLoading[sName] = nil\n"
"            return false\n"
"        end\n"
"    else\n"
"        printError( err )\n"
"        tAPIsLoading[sName] = nil\n"
"        return false\n"
"    end\n"
"    \n"
"    local tAPI = {}\n"
"    for k,v in pairs( tEnv ) do\n"
"        if k ~= \"_ENV\" then\n"
"            tAPI[k] =  v\n"
"        end\n"
"    end\n"
"\n"
"    _G[sName] = tAPI    \n"
"    tAPIsLoading[sName] = nil\n"
"    return true\n"
"end\n"
"\n"
"function os.unloadAPI( _sName )\n"
"    if type( _sName ) ~= \"string\" then\n"
"        error( \"bad argument #1 (expected string, got \" .. type( _sName ) .. \")\", 2 ) \n"
"    end\n"
"    if _sName ~= \"_G\" and type(_G[_sName]) == \"table\" then\n"
"        _G[_sName] = nil\n"
"    end\n"
"end\n"
"\n"
"function os.sleep( nTime )\n"
"    sleep( nTime )\n"
"end\n"
"\n"
"local nativeShutdown = os.shutdown\n"
"function os.shutdown()\n"
"    nativeShutdown()\n"
"    while true do\n"
"        coroutine.yield()\n"
"    end\n"
"end\n"
"\n"
"local nativeReboot = os.reboot\n"
"function os.reboot()\n"
"    nativeReboot()\n"
"    while true do\n"
"        coroutine.yield()\n"
"    end\n"
"end\n"
"\n"
"-- Install the lua part of the HTTP api (if enabled)\n"
"if http then\n"
"    local nativeHTTPRequest = http.request\n"
"\n"
"    local function wrapRequest( _url, _post, _headers, _binary )\n"
"        local ok, err = nativeHTTPRequest( _url, _post, _headers, _binary )\n"
"        if ok then\n"
"            while true do\n"
"                local event, param1, param2, param3 = os.pullEvent()\n"
"                if event == \"http_success\" and param1 == _url then\n"
"                    return param2\n"
"                elseif event == \"http_failure\" and param1 == _url then\n"
"                    return nil, param2, param3\n"
"                end\n"
"            end\n"
"        end\n"
"        return nil, err\n"
"    end\n"
"    \n"
"    http.get = function( _url, _headers, _binary)\n"
"        if type( _url ) ~= \"string\" then\n"
"            error( \"bad argument #1 (expected string, got \" .. type( _url ) .. \")\", 2 ) \n"
"        end\n"
"        if _headers ~= nil and type( _headers ) ~= \"table\" then\n"
"            error( \"bad argument #2 (expected table, got \" .. type( _headers ) .. \")\", 2 ) \n"
"        end\n"
"        if _binary ~= nil and type( _binary ) ~= \"boolean\" then\n"
"            error( \"bad argument #3 (expected boolean, got \" .. type( _binary ) .. \")\", 2 ) \n"
"        end\n"
"        return wrapRequest( _url, nil, _headers, _binary)\n"
"    end\n"
"\n"
"    http.post = function( _url, _post, _headers, _binary)\n"
"        if type( _url ) ~= \"string\" then\n"
"            error( \"bad argument #1 (expected string, got \" .. type( _url ) .. \")\", 2 ) \n"
"        end\n"
"        if type( _post ) ~= \"string\" then\n"
"            error( \"bad argument #2 (expected string, got \" .. type( _post ) .. \")\", 2 ) \n"
"        end\n"
"        if _headers ~= nil and type( _headers ) ~= \"table\" then\n"
"            error( \"bad argument #3 (expected table, got \" .. type( _headers ) .. \")\", 2 ) \n"
"        end\n"
"        if _binary ~= nil and type( _binary ) ~= \"boolean\" then\n"
"            error( \"bad argument #4 (expected boolean, got \" .. type( _binary ) .. \")\", 2 ) \n"
"        end\n"
"        return wrapRequest( _url, _post or \"\", _headers, _binary)\n"
"    end\n"
"\n"
"    http.request = function( _url, _post, _headers, _binary )\n"
"        if type( _url ) ~= \"string\" then\n"
"            error( \"bad argument #1 (expected string, got \" .. type( _url ) .. \")\", 2 ) \n"
"        end\n"
"        if _post ~= nil and type( _post ) ~= \"string\" then\n"
"            error( \"bad argument #2 (expected string, got \" .. type( _post ) .. \")\", 2 ) \n"
"        end\n"
"        if _headers ~= nil and type( _headers ) ~= \"table\" then\n"
"            error( \"bad argument #3 (expected table, got \" .. type( _headers ) .. \")\", 2 ) \n"
"        end\n"
"        if _binary ~= nil and type( _binary ) ~= \"boolean\" then\n"
"            error( \"bad argument #4 (expected boolean, got \" .. type( _binary ) .. \")\", 2 ) \n"
"        end\n"
"        local ok, err = nativeHTTPRequest( _url, _post, _headers, _binary )\n"
"        if not ok then\n"
"            os.queueEvent( \"http_failure\", _url, err )\n"
"        end\n"
"        return ok, err\n"
"    end\n"
"    \n"
"    local nativeCheckURL = http.checkURL\n"
"    http.checkURLAsync = nativeCheckURL\n"
"    http.checkURL = function( _url )\n"
"        local ok, err = nativeCheckURL( _url )\n"
"        if not ok then return ok, err end\n"
"    \n"
"        while true do\n"
"            local event, url, ok, err = os.pullEvent( \"http_check\" )\n"
"            if url == _url then return ok, err end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- Install the lua part of the FS api\n"
"local tEmpty = {}\n"
"function fs.complete( sPath, sLocation, bIncludeFiles, bIncludeDirs )\n"
"    if type( sPath ) ~= \"string\" then\n"
"        error( \"bad argument #1 (expected string, got \" .. type( sPath ) .. \")\", 2 ) \n"
"    end\n"
"    if type( sLocation ) ~= \"string\" then\n"
"        error( \"bad argument #2 (expected string, got \" .. type( sLocation ) .. \")\", 2 ) \n"
"    end\n"
"    if bIncludeFiles ~= nil and type( bIncludeFiles ) ~= \"boolean\" then\n"
"        error( \"bad argument #3 (expected boolean, got \" .. type( bIncludeFiles ) .. \")\", 2 ) \n"
"    end\n"
"    if bIncludeDirs ~= nil and type( bIncludeDirs ) ~= \"boolean\" then\n"
"        error( \"bad argument #4 (expected boolean, got \" .. type( bIncludeDirs ) .. \")\", 2 ) \n"
"    end\n"
"    bIncludeFiles = (bIncludeFiles ~= false)\n"
"    bIncludeDirs = (bIncludeDirs ~= false)\n"
"    local sDir = sLocation\n"
"    local nStart = 1\n"
"    local nSlash = string.find( sPath, \"[/\\\\]\", nStart )\n"
"    if nSlash == 1 then\n"
"        sDir = \"\"\n"
"        nStart = 2\n"
"    end\n"
"    local sName\n"
"    while not sName do\n"
"        local nSlash = string.find( sPath, \"[/\\\\]\", nStart )\n"
"        if nSlash then\n"
"            local sPart = string.sub( sPath, nStart, nSlash - 1 )\n"
"            sDir = fs.combine( sDir, sPart )\n"
"            nStart = nSlash + 1\n"
"        else\n"
"            sName = string.sub( sPath, nStart )\n"
"        end\n"
"    end\n"
"\n"
"    if fs.isDir( sDir ) then\n"
"        local tResults = {}\n"
"        if bIncludeDirs and sPath == \"\" then\n"
"            table.insert( tResults, \".\" )\n"
"        end\n"
"        if sDir ~= \"\" then\n"
"            if sPath == \"\" then\n"
"                table.insert( tResults, (bIncludeDirs and \"..\") or \"../\" )\n"
"            elseif sPath == \".\" then\n"
"                table.insert( tResults, (bIncludeDirs and \".\") or \"./\" )\n"
"            end\n"
"        end\n"
"        local tFiles = fs.list( sDir )\n"
"        for n=1,#tFiles do\n"
"            local sFile = tFiles[n]\n"
"            if #sFile >= #sName and string.sub( sFile, 1, #sName ) == sName then\n"
"                local bIsDir = fs.isDir( fs.combine( sDir, sFile ) )\n"
"                local sResult = string.sub( sFile, #sName + 1 )\n"
"                if bIsDir then\n"
"                    table.insert( tResults, sResult .. \"/\" )\n"
"                    if bIncludeDirs and #sResult > 0 then\n"
"                        table.insert( tResults, sResult )\n"
"                    end\n"
"                else\n"
"                    if bIncludeFiles and #sResult > 0 then\n"
"                        table.insert( tResults, sResult )\n"
"                    end\n"
"                end\n"
"            end\n"
"        end\n"
"        return tResults\n"
"    end\n"
"    return tEmpty\n"
"end\n"
"\n"
"-- Load APIs\n"
"local bAPIError = false\n"
"local tApis = fs.list( \"rom/apis\" )\n"
"for n,sFile in ipairs( tApis ) do\n"
"    if string.sub( sFile, 1, 1 ) ~= \".\" then\n"
"        local sPath = fs.combine( \"rom/apis\", sFile )\n"
"        if not fs.isDir( sPath ) then\n"
"            if not os.loadAPI( sPath ) then\n"
"                bAPIError = true\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"if turtle and fs.isDir( \"rom/apis/turtle\" ) then\n"
"    -- Load turtle APIs\n"
"    local tApis = fs.list( \"rom/apis/turtle\" )\n"
"    for n,sFile in ipairs( tApis ) do\n"
"        if string.sub( sFile, 1, 1 ) ~= \".\" then\n"
"            local sPath = fs.combine( \"rom/apis/turtle\", sFile )\n"
"            if not fs.isDir( sPath ) then\n"
"                if not os.loadAPI( sPath ) then\n"
"                    bAPIError = true\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"if pocket and fs.isDir( \"rom/apis/pocket\" ) then\n"
"    -- Load pocket APIs\n"
"    local tApis = fs.list( \"rom/apis/pocket\" )\n"
"    for n,sFile in ipairs( tApis ) do\n"
"        if string.sub( sFile, 1, 1 ) ~= \".\" then\n"
"            local sPath = fs.combine( \"rom/apis/pocket\", sFile )\n"
"            if not fs.isDir( sPath ) then\n"
"                if not os.loadAPI( sPath ) then\n"
"                    bAPIError = true\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"if commands and fs.isDir( \"rom/apis/command\" ) then\n"
"    -- Load command APIs\n"
"    if os.loadAPI( \"rom/apis/command/commands.lua\" ) then\n"
"        -- Add a special case-insensitive metatable to the commands api\n"
"        local tCaseInsensitiveMetatable = {\n"
"            __index = function( table, key )\n"
"                local value = rawget( table, key )\n"
"                if value ~= nil then\n"
"                    return value\n"
"                end\n"
"                if type(key) == \"string\" then\n"
"                    local value = rawget( table, string.lower(key) )\n"
"                    if value ~= nil then\n"
"                        return value\n"
"                    end\n"
"                end\n"
"                return nil\n"
"            end\n"
"        }\n"
"        setmetatable( commands, tCaseInsensitiveMetatable )\n"
"        setmetatable( commands.async, tCaseInsensitiveMetatable )\n"
"\n"
"        -- Add global \"exec\" function\n"
"        exec = commands.exec\n"
"    else\n"
"        bAPIError = true\n"
"    end\n"
"end\n"
"\n"
"if bAPIError then\n"
"    print( \"Press any key to continue\" )\n"
"    os.pullEvent( \"key\" )\n"
"    --term.clear()\n"
"    --term.setCursorPos( 1,1 )\n"
"end\n"
"\n"
"-- Set default settings\n"
"settings.set( \"shell.allow_startup\", true )\n"
"settings.set( \"shell.allow_disk_startup\", (commands == nil) )\n"
"settings.set( \"shell.autocomplete\", true )\n"
"settings.set( \"edit.autocomplete\", true ) \n"
"settings.set( \"edit.default_extension\", \"lua\" )\n"
"settings.set( \"paint.default_extension\", \"nfp\" )\n"
"settings.set( \"lua.autocomplete\", true )\n"
"settings.set( \"list.show_hidden\", false )\n"
"if term.isColour() then\n"
"    settings.set( \"bios.use_multishell\", true )\n"
"end\n"
"if _CC_DEFAULT_SETTINGS then\n"
"    for sPair in string.gmatch( _CC_DEFAULT_SETTINGS, \"[^,]+\" ) do\n"
"        local sName, sValue = string.match( sPair, \"([^=]*)=(.*)\" )\n"
"        if sName and sValue then\n"
"            local value\n"
"            if sValue == \"true\" then\n"
"                value = true\n"
"            elseif sValue == \"false\" then\n"
"                value = false\n"
"            elseif sValue == \"nil\" then\n"
"                value = nil\n"
"            elseif tonumber(sValue) then\n"
"                value = tonumber(sValue)\n"
"            else\n"
"                value = sValue\n"
"            end\n"
"            if value ~= nil then\n"
"                settings.set( sName, value )\n"
"            else\n"
"                settings.unset( sName )\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- Load user settings\n"
"if fs.exists( \".settings\" ) then\n"
"    settings.load( \".settings\" )\n"
"end\n"
"\n"
"-- Run the shell\n"
"local ok, err = pcall( function()\n"
"    parallel.waitForAny( \n"
"        function()\n"
"            local sShell\n"
"            if term.isColour() and settings.get( \"bios.use_multishell\" ) then\n"
"                sShell = \"rom/programs/advanced/multishell.lua\"\n"
"            else\n"
"                sShell = \"rom/programs/shell.lua\"\n"
"            end\n"
"            os.run( {}, sShell )\n"
"            os.run( {}, \"rom/programs/shutdown.lua\" )\n"
"        end,\n"
"        function()\n"
"            rednet.run()\n"
"        end )\n"
"end )\n"
"\n"
"-- If the shell errored, let the user read it.\n"
"term.redirect( term.native() )\n"
"if not ok then\n"
"    printError( err )\n"
"    pcall( function()\n"
"        term.setCursorBlink( false )\n"
"        print( \"Press any key to continue\" )\n"
"        os.pullEvent( \"key\" )\n"
"    end )\n"
"end\n"
"\n"
"-- End\n"
"os.shutdown()\n";